---
layout: post
cid: 34
title: Go中的闭包函数作用分析
slug: 34
date: 2021/06/27 17:06:00
updated: 2021/06/27 17:09:05
status: publish
author: sunday
categories: 
  - GOLANG
tags: 
customSummary: 
mathjax: auto
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---

通常情况下，在没有使用闭包的情况下，使用到的变量会成为函数内的全局变量随着共享使用而数据增多，例如以下代码，我们定义了一个任务函数，来通过传入方法的参数来传出每个主函数里面的人行军小时及进度。<!--more--> 


    // 主函数入口
    func main()  {
    	GoToTask("李逵",13)
    	fmt.Printf("进度是:%d \n",Progress)
    
    	GoToTask("武松",14)
    	fmt.Printf("进度是:%d \n",Progress)
    }
    
    // 进度初始值
    var Progress = 0
    
    // 动作函数
    func GoToTask(name string,hours int)  {
    	fmt.Printf("牛逼的 %s 带队行军%d个小时,",name,hours)
    	Progress += hours
    }


以上代码，乍一眼看似乎没有问题，但我们执行后看到执行结果为：

    /*
    牛逼的 李逵 带队行军13个小时,进度是:13
    牛逼的 武松 带队行军14个小时,进度是:27
    */

可以看到，在没有比包的情况下执行，传入的name字段可以随着传递的参数不同而改变，但定义的Progress变量不是自己的，而是前面的人加上他自己的总和。

为此，解决以上问题，Go中的闭包函数可以让我们用少数的代码，来修复上述中的问题，将一个一个获得的内层函数的实例，状态被包含在各自的闭包函数中，如一下代码实例：

    // 主函数入口
    func main()  {
    	Boys01 := GetTaskFunc("李逵")
    	Boys02 := GetTaskFunc("武松")
    
    	Boys01_StartProgress := Boys01(13)
    	Boys02_StartProgress := Boys02(14)
    
    	fmt.Printf("李逵的进度是:%d\n",Boys01_StartProgress)
    	fmt.Printf("武松的进度是:%d\n",Boys02_StartProgress)
    }
    
    /* 获得任务函数,其状态被包裹在闭包内*/
    func GetTaskFunc(name string) func(hours int)(StartProgress int) {
    	// 进度初始值
    	var StartProgress = 0
    	// 动作函数,记得不要忘记进度的返回值类型
    	ToDoTask := func(hours int) int  {
    		fmt.Printf("牛逼的 %s 带队行军%d个小时\n",name,hours)
    		StartProgress += hours
    		return StartProgress
    	}
    	return ToDoTask
    }

执行结果为：

    /*
    牛逼的 李逵 带队行军13个小时
    牛逼的 武松 带队行军14个小时
    李逵的进度是:13
    武松的进度是:14
    */

